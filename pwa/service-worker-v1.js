/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate, CacheFirst } from "workbox-strategies";

clientsClaim();

var currentVersion = "1.0.0"; // Default version

// Function to update caches when the version changes
const updateCaches = async (newVersion) => {
  console.log("caches are", caches);
  if (caches && caches.keys()) {
    const cacheNames = await caches.keys();
    await Promise.all(
      cacheNames.map(async (cacheName) => {
        if (cacheName.includes("-v")) {
          const [baseName, oldVersion] = cacheName.split("-v");
          if (oldVersion !== newVersion) {
            console.log(
              `Updating cache: ${cacheName} to ${baseName}-v${newVersion}`
            );
            const oldCache = await caches.open(cacheName);
            const newCache = await caches.open(`${baseName}-v${newVersion}`);
            const keys = await oldCache.keys();
            await Promise.all(
              keys.map(async (request) => {
                const response = await oldCache.match(request);
                await newCache.put(request, response);
              })
            );
            await caches.delete(cacheName);
          }
        }
      })
    );
  }
};

// This allows the web app to trigger message events
self.addEventListener("message", (event) => {
  console.log("Getting a message by event listener ", event.data);
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }

  if (event.data && event.data.type === "VERSION_CHANGE") {
    currentVersion = event.data.version;
    console.log(`Received version change to: ${currentVersion}`);
    updateCaches(currentVersion);
  }
});

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

self.addEventListener("install", (event) => {
  event.waitUntil(
    Promise.all([
      caches.open(`app-shell-v${currentVersion}`).then((cache) => {
        return cache.addAll([
          "/",
          "/index.html",
          // List specific files or use runtime caching for dynamic assets
        ]);
      }),
      caches.open(`static-assets-v${currentVersion}`).then((cache) => {
        // Add any specific static assets you want to cache initially
        return cache.addAll([
          // List specific static files here
        ]);
      }),
      caches.open(`firebase-storage-v${currentVersion}`).then((cache) => {
        // Optionally, pre-cache some Firebase Storage assets if known
        return cache.addAll([
          // List specific Firebase Storage files here
        ]);
      }),
      caches.open(`images-v${currentVersion}`).then((cache) => {
        // Optionally, pre-cache some images if known
        return cache.addAll([
          // List specific image files here
        ]);
      }),
    ])
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (!cacheName.endsWith(`v${currentVersion}`)) {
            return caches.delete(cacheName);
          }
          return null;
        })
      );
    })
  );
});

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(({ request, url }) => {
  if (request.mode !== "navigate") {
    return false;
  }
  if (url.pathname.startsWith("/_")) {
    return false;
  }
  if (url.pathname.match(fileExtensionRegexp)) {
    return false;
  }
  return true;
}, createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html"));

// Cache .png requests
registerRoute(
  ({ url }) =>
    url.origin === self.location.origin && url.pathname.endsWith(".png"),
  new StaleWhileRevalidate({
    cacheName: `images-v${currentVersion}`,
    plugins: [new ExpirationPlugin({ maxEntries: 50 })],
  })
);

// Cache Firebase Storage requests
registerRoute(
  ({ url }) => url.origin === "https://firebasestorage.googleapis.com",
  new StaleWhileRevalidate({
    cacheName: `firebase-storage-v${currentVersion}`,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 Days
      }),
    ],
  })
);

// Cache static assets dynamically
registerRoute(
  ({ request }) =>
    request.destination === "script" ||
    request.destination === "style" ||
    request.destination === "image",
  new CacheFirst({
    cacheName: `static-assets-v${currentVersion}`,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);
